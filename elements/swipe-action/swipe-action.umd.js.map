{"version":3,"file":"swipe-action.umd.js","sources":["swipe-action.umd.js"],"sourcesContent":["import { html, Polymer } from \"@polymer/polymer/polymer-legacy.js\";\nimport { dom } from \"@polymer/polymer/lib/legacy/polymer.dom.js\";\nimport { IronResizableBehavior } from \"@polymer/iron-resizable-behavior/iron-resizable-behavior.js\";\n\n/**\n * Helper object describing an action to be triggered by a swipe gesture.\n */\nvar Action = function(\n  id,\n  node,\n  size,\n  requestedSize,\n  rubberBand,\n  fade,\n  maxRubberBandReached,\n  axis,\n  direction\n) {\n  this.id = id;\n  this.node = node;\n  this.size = size;\n  this.requestedSize = requestedSize;\n  this.rubberBand = rubberBand;\n  this.fade = fade;\n  this.maxRubberBandReached = maxRubberBandReached;\n  this.axis = axis;\n  this.direction = direction;\n};\nAction.prototype = {\n  constructor: Action,\n  id: \"right\",\n  node: undefined,\n  size: undefined,\n  requestedSize: undefined,\n  rubberBand: false,\n  fade: false,\n  maxRubberBandReached: false,\n  axis: \"x\",\n  direction: 1\n};\n\nPolymer({\n  _template: html`\n    <style>\n      :host {\n        display: block;\n        position: relative;\n      }\n\n      :host([is-swiping]) {\n        z-index: 1001;\n      }\n\n      :host > ::content > * {\n        position: absolute;\n        box-sizing: border-box;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        height: 100%;\n      }\n\n      ::content > [swipe-left-action] {visibility: hidden;}\n      ::content > [swipe-right-action] {visibility: hidden;}\n      ::content > [swipe-up-action] {visibility: hidden;}\n      ::content > [swipe-down-action] {visibility: hidden;}\n\n      ::content > .visible-action {\n        visibility: visible;\n      }\n\n      #swipeTarget {\n        @apply --swipe-action-swipe-target;\n      }\n\n      #swipeTarget.fade {\n        opacity: 0 !important;\n      }\n\n      #swipeTarget.snap-back {\n        -webkit-transform: none !important;\n        transform: none !important;\n        opacity: 1 !important;\n      }\n\n      #swipeTarget.snap-back.animated {\n        transition: all 200ms ease-in-out;\n      }\n    </style>\n\n    <slot id=\"actions\" name=\"[swipe-left-action],[swipe-right-action],[swipe-up-action],[swipe-down-action]\"></slot>\n    \n    <div id=\"swipeTarget\">\n      <slot id=\"content\"></slot>\n    </div>\n`,\n\n  is: \"swipe-action\",\n\n  /**\n   * Fired when the target has been swiped away and a swipe action\n   * has been triggered as a result.\n   *\n   * Content of the event's `detail` property:\n   *\n   *     {\n   *       action: { // The related action\n   *         id, // {String} Id of the action. One of\n   *           // `window.SwipeAction.ACTION_LEFT`,\n   *           // `window.SwipeAction.ACTION_RIGHT`,\n   *           // `window.SwipeAction.ACTION_UP`,\n   *           // `window.SwipeAction.ACTION_DOWN`\n   *         node, // {Object} The action's DOM node\n   *         size, // {Number} The actual size of the action\n   *         requestedSize, // {Number} The requested size of\n   *           // the action (as per the `swipe-size` attribute)\n   *         rubberBand, // {Boolean} The requested size of the\n   *           // action (as per the `swipe-rubber-band` attr.)\n   *         fade, // {Boolean} `true` if the swipeable item\n   *           // fades when swiped\n   *           // (as per the `swipe-fade` attribute)\n   *         maxRubberBandReached, // {Boolean} `true` if the\n   *           // swipeable item was swiped all the way\n   *           // to maximize the rubber band effect\n   *         axis, // {String} The axis of the action\n   *           // (either `x` or `y`)\n   *         direction // {Number} The direction of the action\n   *           // along it's axis (either `1` or `-1`)\n   *       },\n   *       gesture: { // The triggering swipe gesture\n   *         axis, // {String} The axis of the action\n   *           // (either `x` or `y`)\n   *         direction, // {Number} The direction of the action\n   *           // along it's axis (either `1` or `-1`)\n   *         lastDelta, // {Number} change in pixels along the\n   *           // `axis` since last track event\n   *         lastDeltaDuration, // {Number} Time in ms since\n   *           // last track event\n   *         lastTimestamp // {Number} Timestamp in ms\n   *           //of last track event\n   *       }\n   *     }\n   *\n   * @event swiped-away\n   */\n\n  /**\n   * Fired when a swipe has been canceled (ie a pending swipe action\n   * has not been 'validated' by the user) or reset (ie an action was\n   * triggered and then has been reset).\n   *\n   * Content of the event's `detail` property: See the `swiped-away` event.\n   *\n   * @event swipe-canceled\n   */\n\n  /**\n   * Fired when the target is swiped, whenever the rubber band effect reaches\n   * it's limit (ie the target can't swipe be swiped further).\n   *\n   * Fired once per swipe and per swipe action\n   * (unless the action to be triggered changes during a swipe,\n   * in which case the event can be fired again once after each change).\n   *\n   * Does not fire if the `swipe-rubber-band` argument of the swipe action is set\n   * to 0 (default), or if the `swipe-fade` argument is set for the swipe action.\n   *\n   * Content of the event's `detail` property: See the `swiped-away` event.\n   *\n   * @event swipe-rubber-band-limit\n   */\n\n  properties: {\n    /**\n     * If set, the swipe gesture will be disabled. Actions can only be activated\n     * via the `activateAction` function or by setting the `activatedActionId` property.\n     */\n    gestureDisabled: {\n      type: Boolean,\n      value: false,\n      reflectToAttribute: true,\n      observer: \"_refreshActions\"\n    },\n\n    /**\n     * Flag set to true when the element is being swiped via a gesture.\n     */\n    isSwiping: {\n      type: Boolean,\n      value: false,\n      readOnly: true,\n      notify: true,\n      reflectToAttribute: true\n    },\n\n    /**\n     * Flag set to true when the element has been swiped away.\n     */\n    isSwipedAway: {\n      type: Boolean,\n      value: false,\n      readOnly: true,\n      notify: true,\n      reflectToAttribute: true\n    },\n\n    /**\n     * The currently activated action, if there is one.\n     * Read-only.\n     */\n    activatedAction: {\n      type: Action,\n      value: undefined,\n      readOnly: true,\n      notify: true\n    },\n\n    /**\n     * The ID of the activated action. One of `window.SwipeAction.ACTION_LEFT`,\n     * `window.SwipeAction.ACTION_RIGHT`, `window.SwipeAction.ACTION_UP`, `window.SwipeAction.ACTION_DOWN`\n     *\n     * Setting this property will activate/deactivate action(s) but without any animation,\n     * and without triggering any event.\n     * Bind this property to your model when using `iron-list` to persist the activated action.\n     *\n     * If you want to programmatically activate/deactivate an action, take a look at\n     * the `activateAction` and `reset` functions.\n     */\n    activatedActionId: {\n      type: String,\n      value: undefined,\n      notify: true,\n      observer: \"_onActivatedActionIdChange\"\n    },\n\n    _SWIPE_SPEED_THREASHOLD: {\n      type: Number,\n      value: 10,\n      readOnly: true\n    },\n\n    _OPPOSITE_AXIS_MAX_SCROLLING_THREASHOLD: {\n      type: Number,\n      value: 10,\n      readOnly: true\n    },\n\n    _SWIPE_TRANSITION: {\n      type: String,\n      value: \"all 200ms ease-in-out\",\n      readOnly: true\n    },\n\n    _ACTIONS_CONFIG: {\n      type: Array,\n      value: function() {\n        return [\n          { attr: \"swipe-left-action\", id: window.SwipeAction.ACTION_LEFT },\n          { attr: \"swipe-right-action\", id: window.SwipeAction.ACTION_RIGHT },\n          { attr: \"swipe-up-action\", id: window.SwipeAction.ACTION_UP },\n          { attr: \"swipe-down-action\", id: window.SwipeAction.ACTION_DOWN }\n        ];\n      },\n      readOnly: true\n    },\n\n    /**\n     * Data describing the ongoing swipe gesture.\n     */\n    _gesture: {\n      type: Object,\n      value: null\n    }\n  },\n\n  behaviors: [IronResizableBehavior, MutationObserverBehavior],\n\n  listeners: {\n    \"iron-resize\": \"_onResize\",\n    \"dom-mutation\": \"_refreshActions\"\n  },\n\n  ready: function() {\n    // mutation observer setup\n    this._mutationOptions = {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      characterData: false,\n      attributeFilter: this._ACTIONS_CONFIG.map(function(config) {\n        return config.attr;\n      })\n    };\n    this._mutationFilter = function(mutation) {\n      return (\n        this._mutationIsChildList(mutation, this.$.actions) ||\n        this._mutationIsChildAttributes(mutation, this.$.actions)\n      );\n    };\n\n    this.target = this.$.swipeTarget;\n    this.listen(this.target, \"track\", \"_onTrack\");\n    this.listen(this.target, \"transitionend\", \"_onTransitionEnd\");\n    this._refreshActions();\n  },\n\n  detached: function() {\n    this.unlisten(this.target, \"track\", \"_onTrack\");\n    this.unlisten(this.target, \"transitionend\", \"_onTransitionEnd\");\n  },\n\n  /**\n   * Reset the item to it's initial state (not swiped away) and cancel\n   * any activated action.\n   *\n   * @param {Boolean} animate Whether or not to animate the item whilst\n   * the item is being reseted\n   */\n  reset: function(animate) {\n    // Snap the item back into place\n    this._snapBack(animate);\n  },\n\n  /**\n   * Programmatically activate a swipe action.\n   *\n   * @param {String} actionId The ID of the action to activate. One of `window.SwipeAction.ACTION_LEFT`,\n   * `window.SwipeAction.ACTION_RIGHT`, `window.SwipeAction.ACTION_UP`, `window.SwipeAction.ACTION_DOWN`.\n   * @param {Boolean} animate Whether or not to animate the item whilst\n   * the item is being activated\n   */\n  activateAction: function(actionId, animate) {\n    this._animateActivation = animate;\n    // Compute to action details\n    var actionToActivate = this._actionsMap[actionId];\n    var activatedId = this.activatedAction\n      ? this.activatedAction.id\n      : undefined;\n    var toActivateId = actionToActivate ? actionToActivate.id : undefined;\n    if (activatedId === toActivateId) {\n      // Already activated => nothing to do\n      return;\n    } else if (!toActivateId && activatedId) {\n      // No action to activate, let's just reset the one currently activated\n      this.reset(animate);\n    } else {\n      // If there is on action to activate indeed, keep track of it\n      this._currentAction = actionToActivate;\n      if (this.activatedAction) {\n        // Snap back previous action before\n        this.listen(this, \"swipe-canceled\", \"_activateCurrentAction\");\n        this.reset(animate);\n      } else {\n        // If no activated action, directly activate the new one\n        this._activateCurrentAction();\n      }\n    }\n  },\n\n  _activateCurrentAction: function() {\n    this.unlisten(this, \"swipe-canceled\", \"_activateCurrentAction\");\n    if (this._currentAction) {\n      // Update all the action nodes\n      this._updateActions(\n        this._currentAction.axis,\n        this._currentAction.direction\n      );\n      // Actually swipe away the current action (this._currentAction)\n      this._swipeAway(\n        this._currentAction,\n        this._animateActivation ? this._SWIPE_TRANSITION : \"\"\n      );\n    }\n  },\n\n  _onActivatedActionIdChange: function(newValue, oldValue) {\n    if (!this._activatedActionIdAlreadyChanged) {\n      this._mutationObserverPaused = true;\n      this._mute = 1;\n      if (!newValue) {\n        this._mute++;\n        this.reset(false);\n      } else {\n        this.activateAction(newValue, false);\n      }\n    }\n    this._activatedActionIdAlreadyChanged = false;\n  },\n\n  _onResize: function() {\n    this.debounce(\"_refreshActions\", this._refreshActions, 100);\n  },\n\n  _refreshActions: function() {\n    if (this.target && this._ACTIONS_CONFIG) {\n      // Cache the size of the swipeable node.\n      this._targetHeight = this.target.offsetHeight;\n      this._targetWidth = this.target.offsetWidth;\n\n      var action,\n        map = {},\n        canSwipeX = false,\n        canSwipeY = false;\n      // Build a model for every action declared in the light DOM\n      this.getContentChildren(\"#actions\").forEach(function(el) {\n        this._ACTIONS_CONFIG.forEach(function(config) {\n          if (el.hasAttribute(config.attr)) {\n            action = this._actionFactory(config.id, el);\n            map[config.id] = action;\n            canSwipeX = canSwipeX || action.axis === \"x\";\n            canSwipeY = canSwipeY || action.axis === \"y\";\n          }\n        }, this);\n      }, this);\n      this._actionsMap = map;\n\n      // Computing which scroll direction(s) is/are allowed\n      this.setScrollDirection(\n        this.gestureDisabled || (!canSwipeX && !canSwipeY)\n          ? \"all\"\n          : !canSwipeX\n            ? \"x\"\n            : !canSwipeY\n              ? \"y\"\n              : \"none\",\n        this.target\n      );\n    }\n  },\n\n  _actionFactory: function(actionId, actionNode) {\n    if (!actionNode) {\n      return null;\n    }\n    var sizeAttr = Number(actionNode.getAttribute(\"swipe-size\")) || null;\n    var fadeAttr = actionNode.getAttribute(\"swipe-fade\");\n    var rubberBandAttr = Number(actionNode.getAttribute(\"swipe-rubber-band\"));\n    return new Action(\n      actionId,\n      actionNode,\n      sizeAttr ||\n        (actionId === window.SwipeAction.ACTION_UP ||\n        actionId === window.SwipeAction.ACTION_DOWN\n          ? this._targetHeight\n          : this._targetWidth),\n      sizeAttr,\n      isNaN(rubberBandAttr) ? 60 : rubberBandAttr,\n      fadeAttr || fadeAttr === \"\",\n      false,\n      actionId === window.SwipeAction.ACTION_UP ||\n      actionId === window.SwipeAction.ACTION_DOWN\n        ? \"y\"\n        : \"x\",\n      actionId === window.SwipeAction.ACTION_LEFT ||\n      actionId === window.SwipeAction.ACTION_UP\n        ? -1\n        : 1\n    );\n  },\n\n  _getActionId: function(axis, direction) {\n    if (direction > 0) {\n      return axis === \"x\"\n        ? window.SwipeAction.ACTION_RIGHT\n        : window.SwipeAction.ACTION_DOWN;\n    } else {\n      return axis === \"x\"\n        ? window.SwipeAction.ACTION_LEFT\n        : window.SwipeAction.ACTION_UP;\n    }\n  },\n\n  /**\n   * Computes the swiping direction\n   */\n  _getSwipingDirection: function(e, axis) {\n    return e.detail[\"d\" + axis] > 0 ? 1 : -1;\n  },\n\n  /**\n   * Track gesture handler\n   */\n  _onTrack: function(e) {\n    // Track only when not already swiped away\n    if (!this.isSwipedAway && !this.gestureDisabled) {\n      switch (e.detail.state) {\n        case \"start\":\n          this._swipeStart(e);\n          break;\n        case \"track\":\n          if (this.isSwiping) {\n            this._swipeUpdate(e);\n          }\n          break;\n        case \"end\":\n          if (this.isSwiping) {\n            this._swipeEnd(e);\n          }\n          break;\n      }\n    }\n  },\n\n  _swipeStart: function(e) {\n    this._mutationObserverPaused = true;\n    // Set the swipe axis when starting: it must not change once set for the current swipe\n    this._gesture = {\n      axis: Math.abs(e.detail.dx) > Math.abs(e.detail.dy) ? \"x\" : \"y\"\n    };\n    var oppositeAxis = this._gesture.axis === \"x\" ? \"y\" : \"x\";\n    this._gesture.direction = this._getSwipingDirection(e, this._gesture.axis);\n    this._gesture.lastTimestamp = Date.now();\n    // Initialize the action\n    this._updateActions(this._gesture.axis, this._gesture.direction);\n    // Prevent the swipe if one of the following conditions is met:\n    // - no swipe action is found for the gesture\n    // - the gesture is diagonal (this is most likely a weird scroll gesture)\n    var validateSwipe =\n      this._currentAction &&\n      Math.abs(e.detail[\"d\" + oppositeAxis]) <=\n        this._OPPOSITE_AXIS_MAX_SCROLLING_THREASHOLD;\n    this._setIsSwiping(validateSwipe);\n    if (!validateSwipe) {\n      return;\n    }\n    // Translate to element\n    this.target.style.willChange = \"transform\";\n    this._applyGestureTranslation(\n      e.detail[\"d\" + this._gesture.axis],\n      this._gesture.axis\n    );\n  },\n\n  _swipeUpdate: function(e) {\n    var newSwipingDirection = this._getSwipingDirection(e, this._gesture.axis);\n    var track = e.detail[\"d\" + this._gesture.axis];\n    // If the swiping direction changes, the action to display may also have changed\n    if (newSwipingDirection != this._gesture.direction) {\n      this._gesture.direction = newSwipingDirection;\n      this._updateActions(this._gesture.axis, this._gesture.direction);\n      this.target.style.opacity = 1;\n    }\n    // Cache the last track delta to assess the swipe speed when the 'track end' event is fired\n    var newTimestamp = Date.now();\n    this._gesture.lastDelta = e.detail[\"dd\" + this._gesture.axis];\n    this._gesture.lastDeltaDuration =\n      newTimestamp - this._gesture.lastTimestamp;\n    this._gesture.lastTimestamp = newTimestamp;\n    // Translate\n    this._applyGestureTranslation(track, this._gesture.axis);\n    // Fade it as well if it is required\n    if (this._currentAction.fade) {\n      this.target.style.opacity =\n        1 - Math.abs(track) / this._currentAction.size;\n    }\n  },\n\n  _swipeEnd: function(e) {\n    var absTranslation = Math.abs(e.detail[\"d\" + this._gesture.axis]);\n    var transition;\n    // If exactly swiped away (tracked futher than the size of the action, without rubberBandAttr effect),\n    // we don't need any transition\n    if (\n      absTranslation >= this._currentAction.size &&\n      !this._currentAction.rubberBand\n    ) {\n      transition = \"\";\n    }\n    // Swipe the item all the way if it was fast.\n    else if (\n      absTranslation < this._currentAction.size &&\n      this._gesture.lastDelta * this._gesture.direction >\n        this._SWIPE_SPEED_THREASHOLD\n    ) {\n      transition = \"all \";\n      transition += Math.floor(\n        Math.min(\n          200,\n          ((this._currentAction.size - absTranslation) /\n            (this._gesture.lastDelta * this._gesture.direction)) *\n            this._gesture.lastDeltaDuration\n        )\n      );\n      transition += \"ms linear\";\n    }\n    // Slide all the way off (left/right) if we're 50% total size\n    else if (absTranslation >= this._currentAction.size / 2) {\n      transition = this._SWIPE_TRANSITION;\n    }\n    // Swipe not confirmed, the swipe target should snap back\n    else {\n      this._snapBack(true);\n      return;\n    }\n    // Do swipe away\n    this._swipeAway(this._currentAction, transition);\n  },\n\n  /**\n   * Update the actions objects, and initialize the currently visible one\n   */\n  _updateActions: function(axis, direction) {\n    var actionId = this._getActionId(axis, direction);\n    // Get the Action matching the action identifier\n    this._currentAction = this._actionsMap[actionId];\n    // Toggle visibility for the resolved action\n    for (actionId in this._actionsMap) {\n      dom(this._actionsMap[actionId].node).classList.remove(\"visible-action\");\n    }\n    if (this._currentAction) {\n      dom(this._currentAction.node).classList.add(\"visible-action\");\n    }\n  },\n\n  _swipeAway: function(action, transition) {\n    this.target.style.transition = transition;\n    this._willBeSwipedAway = true;\n    // Apply CSS transformations\n    if (action.fade) {\n      dom(this.target).classList.add(\"fade\");\n    }\n    Polymer.Base.transform(\n      this._getTranslate3d(action.direction * action.size, action.axis),\n      this.target\n    );\n\n    // If there we don't transition, the end handler won't run, so let's handle the cleanup now\n    if (!transition) {\n      this._cleanupAfterTransition();\n    }\n  },\n\n  _snapBack: function(animate) {\n    if (this.isSwiping || this.isSwipedAway) {\n      dom(this.target).classList.add(\"snap-back\");\n    }\n    // Animation\n    if (animate) {\n      dom(this.target).classList.add(\"animated\");\n    } else {\n      this.target.style.transition = \"\";\n      this._cleanupAfterTransition();\n    }\n  },\n\n  _onTransitionEnd: function(e) {\n    if (dom(e).rootTarget === this.target) {\n      // Prevent transitionend event from bubbling up further.\n      e.stopPropagation();\n      // Cleanup after the transition\n      if (e.propertyName === \"transform\") {\n        this._cleanupAfterTransition();\n      }\n    }\n  },\n\n  _cleanupAfterTransition: function() {\n    // If item is swiped away, the swipe-action is activated: fire the appropriate event\n    if (this._willBeSwipedAway) {\n      this._willBeSwipedAway = false;\n      this._changeActivatedAction(this._currentAction);\n      // Fire activation event\n      this._fireEvent(\"swiped-away\");\n      return;\n    }\n    // If the target node won't be swiped away, then it will be snaped back,\n    // and the action won't be activated anymore\n    else if (dom(this.target).classList.contains(\"snap-back\")) {\n      this._changeActivatedAction(undefined);\n      // Fire cancelation event\n      this._fireEvent(\"swipe-canceled\");\n    }\n    // Cleanup to do AFTER the event is fired\n    this._mute--;\n  },\n\n  _fireEvent: function(eventName) {\n    if (!this._mute) {\n      this.fire(eventName, {\n        action: this._currentAction,\n        gesture: this._gesture\n      });\n    }\n  },\n\n  /**\n   * Do change the activatedAction after a swipe or when set programmatically.\n   */\n  _changeActivatedAction: function(action) {\n    var actionId = action ? action.id : undefined;\n    // Set the `activatedActionId` property accordingly\n    if (this.activatedActionId !== actionId) {\n      // Flag the `activatedActionId` property as 'just changed', no computing needed on that front\n      this._activatedActionIdAlreadyChanged = true;\n      this.activatedActionId = actionId;\n    }\n    // Reset stuff if the activated action is unset\n    if (!action) {\n      // Removing inline styles\n      Polymer.Base.transform(\"\", this.target);\n      this.target.style.opacity = \"\";\n      // Removing state classes (multiple calls to avoid IE bug)\n      var classList = dom(this.target).classList;\n      classList.remove(\"snap-back\");\n      classList.remove(\"animated\");\n      classList.remove(\"fade\");\n    }\n    // Actually set the value\n    this._setActivatedAction(action);\n    // Set correct values to bindable attributes and do some cleanup\n    this.target.style.transition = \"\";\n    this.target.style.willChange = \"\";\n    this._gesture = undefined;\n    this._mutationObserverPaused = false;\n    this._setIsSwipedAway(!!action);\n    this._setIsSwiping(false);\n  },\n\n  /**\n   * Computes the translation along the correct axis\n   */\n  _getTranslate3d: function(translation, axis) {\n    var t = axis === \"x\" ? translation + \"px, 0\" : \"0, \" + translation + \"px\";\n    return \"translate3d(\" + t + \", 0)\";\n  },\n\n  /**\n   * Translate the target to match the swipe gesture\n   */\n  _applyGestureTranslation: function(track, axis) {\n    var translation = track;\n    // Transform the translation to apply the 'rubber band' effect if requested\n    if (!this._currentAction.rubberBand || this._currentAction.fade) {\n      translation =\n        this._currentAction.direction *\n        Math.min(Math.abs(translation), this._currentAction.size);\n    } else {\n      translation = this._applyRubberBand(translation);\n    }\n    // Apply the translation\n    Polymer.Base.transform(\n      this._getTranslate3d(translation, axis),\n      this.target\n    );\n  },\n\n  /**\n   * Calculate the translation to apply to create the rubber band effect.\n   * If the limit is reached, fire the approriate event.\n   */\n  _applyRubberBand: function(track) {\n    var absTrack = Math.abs(track);\n    // The rubber band effect spans at least 3.5 times the rubber band area size\n    var rubberBandTrackLength = Math.max(\n      this._gesture.direction *\n        (this._currentAction.size + this._currentAction.rubberBand),\n      3.5 * this._currentAction.rubberBand\n    );\n    var actionSizePlusRubberBandTrack =\n      rubberBandTrackLength + this._currentAction.size;\n\n    // Rubber band if swiped past the boundary if the swipe-action\n    if (\n      absTrack > this._currentAction.size &&\n      absTrack < actionSizePlusRubberBandTrack\n    ) {\n      return (\n        this._gesture.direction *\n        this._rubberBand(\n          absTrack,\n          this._currentAction.size,\n          rubberBandTrackLength,\n          this._currentAction.rubberBand\n        )\n      );\n    }\n    // Cap translation once the rubber band limit is reached\n    if (absTrack >= actionSizePlusRubberBandTrack) {\n      // Fire an event when reaching the limit of the rubber band effect\n      if (!this._currentAction.maxRubberBandReached) {\n        this._currentAction.maxRubberBandReached = true;\n        this._fireEvent(\"swipe-rubber-band-limit\");\n      }\n      return (\n        this._gesture.direction *\n        (this._currentAction.size + this._currentAction.rubberBand)\n      );\n    }\n    // Otherwise, just return the unadulterated track position\n    return track;\n  },\n\n  /**\n   * Rubber banding effect when the target node is swiped further than the action allows.\n   */\n  _rubberBand: function(\n    currentTrack,\n    trackForEffectStart,\n    trackForEffectPeak,\n    maxResult\n  ) {\n    // Min of linear & Quadratic ease out (http://gizma.com/easing/#quad2)\n    var res = (currentTrack - trackForEffectStart) / trackForEffectPeak;\n    return Math.min(\n      -maxResult * res * (res - 2) + trackForEffectStart,\n      currentTrack\n    );\n    // TODO in dire need of a better function (always inferior to a linear function)\n    // trackForEffectStart * (1 + log10(currentTrack / trackForEffectStart)) ?\n  }\n});\nObject.defineProperty(window.SwipeAction, \"ACTION_LEFT\", {\n  get: function() {\n    return \"left\";\n  }\n});\nObject.defineProperty(window.SwipeAction, \"ACTION_RIGHT\", {\n  get: function() {\n    return \"right\";\n  }\n});\nObject.defineProperty(window.SwipeAction, \"ACTION_UP\", {\n  get: function() {\n    return \"up\";\n  }\n});\nObject.defineProperty(window.SwipeAction, \"ACTION_DOWN\", {\n  get: function() {\n    return \"down\";\n  }\n});\n"],"names":["Action","id","node","size","requestedSize","rubberBand","fade","maxRubberBandReached","axis","direction","prototype","constructor","undefined","_template","html","is","properties","gestureDisabled","type","Boolean","value","reflectToAttribute","observer","isSwiping","readOnly","notify","isSwipedAway","activatedAction","activatedActionId","String","_SWIPE_SPEED_THREASHOLD","Number","_OPPOSITE_AXIS_MAX_SCROLLING_THREASHOLD","_SWIPE_TRANSITION","_ACTIONS_CONFIG","Array","attr","window","SwipeAction","ACTION_LEFT","ACTION_RIGHT","ACTION_UP","ACTION_DOWN","_gesture","Object","behaviors","IronResizableBehavior","MutationObserverBehavior","listeners","ready","_mutationOptions","childList","subtree","attributes","characterData","attributeFilter","this","map","config","_mutationFilter","mutation","_mutationIsChildList","$","actions","_mutationIsChildAttributes","target","swipeTarget","listen","_refreshActions","detached","unlisten","reset","animate","_snapBack","activateAction","actionId","_animateActivation","actionToActivate","_actionsMap","activatedId","toActivateId","_currentAction","_activateCurrentAction","_updateActions","_swipeAway","_onActivatedActionIdChange","newValue","oldValue","_activatedActionIdAlreadyChanged","_mutationObserverPaused","_mute","_onResize","debounce","_targetHeight","offsetHeight","_targetWidth","offsetWidth","action","canSwipeX","canSwipeY","getContentChildren","forEach","el","hasAttribute","_actionFactory","setScrollDirection","actionNode","sizeAttr","getAttribute","fadeAttr","rubberBandAttr","isNaN","_getActionId","_getSwipingDirection","e","detail","_onTrack","state","_swipeStart","_swipeUpdate","_swipeEnd","Math","abs","dx","dy","oppositeAxis","lastTimestamp","Date","now","validateSwipe","_setIsSwiping","style","willChange","_applyGestureTranslation","newSwipingDirection","track","opacity","newTimestamp","lastDelta","lastDeltaDuration","transition","absTranslation","floor","min","dom","classList","remove","add","_willBeSwipedAway","Polymer","Base","transform","_getTranslate3d","_cleanupAfterTransition","_onTransitionEnd","rootTarget","stopPropagation","propertyName","_changeActivatedAction","_fireEvent","contains","eventName","fire","gesture","_setActivatedAction","_setIsSwipedAway","translation","_applyRubberBand","absTrack","rubberBandTrackLength","max","actionSizePlusRubberBandTrack","_rubberBand","currentTrack","trackForEffectStart","trackForEffectPeak","maxResult","res","defineProperty","get"],"mappings":"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"}